<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>CrossPoint Reader - Settings</title>
  <style>
    :root {
      --black: #000;
      --white: #fff;
      --gray-2: #222;
      --gray-3: #444;
      --gray-4: #666;
      --gray-5: #888;
      --gray-6: #aaa;
      --gray-7: #ccc;
      --gray-8: #ddd;
      --gray-9: #eee;
      --gray-10: #f5f5f5;
      --font-mono: 'Courier New', Courier, monospace;
      --font-display: Georgia, 'Times New Roman', Times, serif;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: var(--font-mono);
      max-width: 800px;
      margin: 0 auto;
      background-color: var(--gray-10);
      color: var(--black);
      background-image: radial-gradient(circle, var(--gray-8) 1px, transparent 1px);
      background-size: 4px 4px;
    }
    h1 {
      font-family: var(--font-display);
      font-weight: 700;
      color: var(--black);
      font-size: 1.4em;
      padding: 14px 16px;
      border-bottom: 2px solid var(--black);
      background: var(--white);
    }
    h2 {
      color: var(--gray-2);
      margin-top: 0;
      font-family: var(--font-mono);
      font-size: 0.82em;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }
    .card {
      background: var(--white);
      padding: 16px;
      margin: 12px 16px;
      border: 2px solid var(--black);
    }
    /* Nav bar matching home page */
    .nav {
      display: flex;
      border-bottom: 2px solid var(--black);
      background: var(--white);
    }
    .nav a {
      flex: 1;
      text-align: center;
      padding: 10px 0;
      text-decoration: none;
      color: var(--black);
      font-family: var(--font-mono);
      font-size: 0.8em;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      border-right: 1px solid var(--gray-7);
      transition: background 0.1s;
    }
    .nav a:last-child { border-right: none; }
    .nav a:hover, .nav a.active {
      background: var(--black);
      color: var(--white);
    }
    .setting-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 0;
      border-bottom: 1px dotted var(--gray-7);
    }
    .setting-row:last-child {
      border-bottom: none;
    }
    .setting-name {
      font-weight: 500;
      color: var(--black);
      flex: 1;
      min-width: 0;
      padding-right: 12px;
      font-size: 0.85em;
    }
    .setting-control {
      flex-shrink: 0;
    }
    .setting-control select,
    .setting-control input[type="number"],
    .setting-control input[type="text"],
    .setting-control input[type="password"] {
      padding: 6px 10px;
      border: 2px solid var(--black);
      font-family: var(--font-mono);
      font-size: 0.85em;
      background: var(--white);
    }
    .setting-control select:focus,
    .setting-control input:focus {
      outline: none;
      border-color: var(--gray-3);
    }
    .setting-control select {
      min-width: 160px;
    }
    .setting-control input[type="text"],
    .setting-control input[type="password"] {
      width: 220px;
    }
    .setting-control input[type="number"] {
      width: 80px;
    }
    /* Toggle switch - grayscale */
    .toggle-switch {
      display: inline-block;
      position: relative;
      width: 44px;
      height: 24px;
    }
    .toggle-switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .toggle-slider {
      position: absolute;
      cursor: pointer;
      top: 0; left: 0; right: 0; bottom: 0;
      background-color: var(--gray-7);
      border: 2px solid var(--gray-5);
      transition: 0.2s;
    }
    .toggle-slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 2px;
      bottom: 2px;
      background-color: var(--white);
      border: 1px solid var(--gray-5);
      transition: 0.2s;
    }
    .toggle-switch input:checked + .toggle-slider {
      background-color: var(--black);
      border-color: var(--black);
    }
    .toggle-switch input:checked + .toggle-slider:before {
      transform: translateX(20px);
      border-color: var(--gray-3);
    }
    .save-container {
      text-align: center;
      margin: 16px;
    }
    .save-btn {
      background: var(--black);
      color: var(--white);
      padding: 12px 40px;
      border: 2px solid var(--black);
      cursor: pointer;
      font-family: var(--font-mono);
      font-size: 0.9em;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }
    .save-btn:hover {
      background: var(--white);
      color: var(--black);
    }
    .save-btn:disabled {
      background: var(--gray-6);
      border-color: var(--gray-6);
      cursor: not-allowed;
    }
    .message {
      padding: 10px;
      margin: 12px 16px;
      text-align: center;
      display: none;
      border: 2px solid var(--black);
      font-size: 0.85em;
    }
    .message.success {
      background: var(--gray-9);
      color: var(--black);
    }
    .message.error {
      background: var(--white);
      color: var(--black);
      border-style: double;
    }
    .loader-container {
      display: flex;
      justify-content: center;
      align-items: center;
      margin: 20px 0;
    }
    .loader {
      width: 40px;
      height: 40px;
      border: 3px solid var(--gray-6);
      border-bottom-color: transparent;
      border-radius: 50%;
      display: inline-block;
      box-sizing: border-box;
      animation: rotation 1s linear infinite;
    }
    @keyframes rotation {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    @media (max-width: 600px) {
      body {
        font-size: 13px;
      }
      .card {
        padding: 12px;
        margin: 8px 10px;
      }
      h1 {
        font-size: 1.2em;
        padding: 12px;
      }
      .setting-row {
        flex-wrap: wrap;
        gap: 6px;
      }
      .setting-control select,
      .setting-control input[type="text"],
      .setting-control input[type="password"] {
        min-width: 0;
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <nav class="nav">
    <a href="/">[Home]</a>
    <a href="/files">[Files]</a>
    <a href="/settings" class="active">[Settings]</a>
  </nav>

  <h1>Settings</h1>

  <div id="message" class="message"></div>

  <div id="settings-container">
    <div class="loader-container">
      <span class="loader"></span>
    </div>
  </div>

  <div class="card" id="fontUploadCard" style="display:none;">
    <h2>Install Font (.cpf)</h2>
    <p style="font-size:0.8em; color:var(--gray-4); margin-bottom:10px;">
      Upload a CPF font file to /fonts/ on the SD card.
      See <code>tools/font-converter/</code> for the conversion tool.
    </p>
    <div class="setting-row">
      <span class="setting-name">Font file (.cpf)</span>
      <span class="setting-control">
        <input type="file" id="fontFileInput" accept=".cpf" style="font-size:0.8em;">
      </span>
    </div>
    <div style="text-align:center; margin-top:10px;">
      <button class="save-btn" style="padding:8px 20px; font-size:0.8em;" onclick="uploadFont()" id="fontUploadBtn">Upload</button>
      <span id="fontUploadStatus" style="font-size:0.8em; margin-left:10px; color:var(--gray-4);"></span>
    </div>
  </div>

  <div class="card" id="ota-container" style="display:none;">
    <h2>Firmware Update</h2>
    <div id="ota-status" style="font-size:0.8em; color:var(--gray-4); margin-bottom:10px;">Check for firmware updates</div>
    <div style="text-align: center; margin-top: 10px;">
      <button class="save-btn" style="padding: 8px 20px; font-size: 0.8em;" onclick="checkForUpdates()" id="otaCheckBtn">Check for Updates</button>
    </div>
  </div>

  <div class="card" id="wifi-container" style="display:none;">
    <h2>WiFi Setup</h2>
    <div id="wifi-networks">
      <p style="font-size: 0.8em; color: var(--gray-5); text-align: center; padding: 10px;">Click 'Scan' to see available networks</p>
    </div>
    <div style="text-align: center; margin-top: 10px;">
      <button class="save-btn" style="padding: 8px 20px; font-size: 0.8em;" onclick="scanWifi()" id="scanBtn">Scan WiFi</button>
    </div>
  </div>

  <div class="save-container" id="save-container" style="display:none;">
    <button class="save-btn" id="saveBtn" onclick="saveSettings()">Save Settings</button>
  </div>

  <div style="text-align:center; padding:12px 16px 20px; font-size:0.65em; color:var(--gray-5); border-top:1px solid var(--gray-7); margin:0 16px; letter-spacing:0.06em;">
    CrossPoint &middot; Open Source &middot; Built for Reading
  </div>

<script>
  let allSettings = [];
  let originalValues = {};
  let touchedFields = {};
  const SETTING_DISPLAY_NAMES = {
    usbMscPromptOnConnect: 'USB Mass Storage Prompt'
  };

  function escapeHtml(unsafe) {
    return unsafe
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  function showMessage(text, isError) {
    const msg = document.getElementById('message');
    msg.textContent = text;
    msg.className = 'message ' + (isError ? 'error' : 'success');
    msg.style.display = 'block';
    setTimeout(function() { msg.style.display = 'none'; }, 4000);
  }

  function renderControl(setting) {
    const id = 'setting-' + setting.key;

    if (setting.type === 'toggle') {
      const checked = setting.value ? 'checked' : '';
      return '<label class="toggle-switch">' +
        '<input type="checkbox" id="' + id + '" ' + checked + ' onchange="markChanged(\'' + setting.key + '\')">' +
        '<span class="toggle-slider"></span></label>';
    }

    if (setting.type === 'enum') {
      let html = '<select id="' + id + '" onchange="markChanged(\'' + setting.key + '\')">';
      setting.options.forEach(function(opt, idx) {
        const selected = idx === setting.value ? ' selected' : '';
        html += '<option value="' + idx + '"' + selected + '>' + escapeHtml(opt) + '</option>';
      });
      html += '</select>';
      return html;
    }

    if (setting.type === 'value') {
      return '<input type="number" id="' + id + '" value="' + setting.value + '"' +
        ' min="' + setting.min + '" max="' + setting.max + '" step="' + setting.step + '"' +
        ' onchange="markChanged(\'' + setting.key + '\')">';
    }

    if (setting.type === 'string') {
      const inputType = setting.name.toLowerCase().includes('password') ? 'password' : 'text';
      const val = setting.value || '';
      const placeholder = inputType === 'password' && setting.hasValue ? ' placeholder="Saved"' : '';
      return '<input type="' + inputType + '" id="' + id + '" value="' + escapeHtml(val) + '"' +
        placeholder + ' oninput="markChanged(\'' + setting.key + '\')">';
    }

    return '';
  }

  function getValue(setting) {
    const el = document.getElementById('setting-' + setting.key);
    if (!el) return undefined;

    if (setting.type === 'toggle') {
      return el.checked ? 1 : 0;
    }
    if (setting.type === 'enum') {
      return parseInt(el.value, 10);
    }
    if (setting.type === 'value') {
      return parseInt(el.value, 10);
    }
    if (setting.type === 'string') {
      return el.value;
    }
    return undefined;
  }

  function markChanged(key) {
    if (key) touchedFields[key] = true;
    document.getElementById('saveBtn').disabled = false;
  }

  function displaySettingName(setting) {
    if (!setting) return '';
    return SETTING_DISPLAY_NAMES[setting.key] || setting.name || '';
  }

  async function loadSettings() {
    try {
      // Check features first to see if we should show WiFi setup
      const featResponse = await fetch('/api/plugins');
      if (featResponse.ok) {
        const features = await featResponse.json();
        if (features.web_wifi_setup) {
          document.getElementById('wifi-container').style.display = 'block';
        }
        if (features.ota_updates) {
          document.getElementById('ota-container').style.display = 'block';
        }
        if (features.user_fonts) {
          document.getElementById('fontUploadCard').style.display = 'block';
        }
      }

      const response = await fetch('/api/settings');
      if (!response.ok) {
        throw new Error('Failed to load settings: ' + response.status);
      }
      allSettings = await response.json();

      // Store original values
      originalValues = {};
      touchedFields = {};
      allSettings.forEach(function(s) {
        originalValues[s.key] = s.value;
      });

      // Group by category
      const groups = {};
      allSettings.forEach(function(s) {
        if (!groups[s.category]) groups[s.category] = [];
        groups[s.category].push(s);
      });

      const container = document.getElementById('settings-container');
      let html = '';

      for (const category in groups) {
        html += '<div class="card"><h2>' + escapeHtml(category) + '</h2>';
        groups[category].forEach(function(s) {
          html += '<div class="setting-row">' +
            '<span class="setting-name">' + escapeHtml(displaySettingName(s)) + '</span>' +
            '<span class="setting-control">' + renderControl(s) + '</span>' +
            '</div>';
        });
        html += '</div>';
      }

      container.innerHTML = html;
      document.getElementById('save-container').style.display = '';
      document.getElementById('saveBtn').disabled = true;
    } catch (e) {
      console.error(e);
      document.getElementById('settings-container').innerHTML =
        '<div class="card"><p style="text-align:center;color:#e74c3c;">Failed to load settings</p></div>';
    }
  }

  async function saveSettings() {
    const btn = document.getElementById('saveBtn');
    btn.disabled = true;
    btn.textContent = 'Saving...';

    // Collect only changed values
    const changes = {};
    allSettings.forEach(function(s) {
      const current = getValue(s);
      const isPasswordField = s.type === 'string' && s.name.toLowerCase().includes('password');
      if (isPasswordField) {
        // Password fields are masked on load; apply only when user explicitly edited.
        if (touchedFields[s.key] && current !== undefined) {
          changes[s.key] = current;
        }
      } else if (current !== undefined && current !== originalValues[s.key]) {
        changes[s.key] = current;
      }
    });

    if (Object.keys(changes).length === 0) {
      showMessage('No changes to save.', false);
      btn.textContent = 'Save Settings';
      return;
    }

    try {
      const response = await fetch('/api/settings', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(changes)
      });

      if (!response.ok) {
        const text = await response.text();
        throw new Error(text || 'Save failed');
      }

      // Update original values to new values
      for (const key in changes) {
        originalValues[key] = changes[key];
        delete touchedFields[key];
      }

      showMessage('Settings saved successfully!', false);
    } catch (e) {
      console.error(e);
      showMessage('Error: ' + e.message, true);
    }

    btn.textContent = 'Save Settings';
  }

  async function scanWifi() {
    const btn = document.getElementById('scanBtn');
    const container = document.getElementById('wifi-networks');
    btn.disabled = true;
    btn.textContent = 'Scanning...';
    container.innerHTML = '<div class="loader-container"><span class="loader" style="width:24px;height:24px;"></span></div>';

    try {
      const response = await fetch('/api/wifi/scan');
      const networks = await response.json();
      
      if (networks.length === 0) {
        container.innerHTML = '<p style="font-size: 0.8em; color: var(--gray-5); text-align: center; padding: 10px;">No networks found</p>';
      } else {
        let html = '';
        networks.forEach(function(net) {
          const lock = net.encrypted ? ' &#128274;' : '';
          const saved = net.saved ? ' <span style="color:var(--gray-5);">(Saved)</span>' : '';
          html += '<div class="setting-row">' +
            '<span class="setting-name">' + escapeHtml(net.ssid) + lock + saved + '</span>' +
            '<span class="setting-control">';
          
          if (net.saved) {
            html += '<button class="save-btn" style="padding:4px 10px; font-size:0.7em; background:var(--gray-3); border-color:var(--gray-3);" onclick="forgetWifi(\'' + escapeHtml(net.ssid) + '\')">Forget</button>';
          } else {
            html += '<button class="save-btn" style="padding:4px 10px; font-size:0.7em;" onclick="connectWifi(\'' + escapeHtml(net.ssid) + '\', ' + net.encrypted + ')">Connect</button>';
          }
          
          html += '</span></div>';
        });
        container.innerHTML = html;
      }
    } catch (e) {
      container.innerHTML = '<p style="font-size: 0.8em; color: var(--black); text-align: center; padding: 10px;">Scan failed</p>';
    }
    btn.disabled = false;
    btn.textContent = 'Scan WiFi';
  }

  async function connectWifi(ssid, encrypted) {
    let password = "";
    if (encrypted) {
      password = prompt("Enter password for " + ssid);
      if (password === null) return;
    }

    try {
      const response = await fetch('/api/wifi/connect', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ ssid: ssid, password: password })
      });
      if (response.ok) {
        showMessage("Credentials saved for " + ssid, false);
        scanWifi();
      } else {
        throw new Error(await response.text());
      }
    } catch (e) {
      showMessage("Error: " + e.message, true);
    }
  }

  async function checkForUpdates() {
    const btn = document.getElementById('otaCheckBtn');
    const statusEl = document.getElementById('ota-status');
    btn.disabled = true;
    btn.textContent = 'Checking...';
    statusEl.textContent = 'Starting update check...';
    statusEl.style.color = 'var(--gray-4)';

    try {
      await fetch('/api/ota/check', { method: 'POST' });

      let attempts = 0;
      const maxAttempts = 30;
      while (attempts < maxAttempts) {
        await new Promise(function(r) { setTimeout(r, 1000); });
        const poll = await fetch('/api/ota/check');
        const result = await poll.json();
        if (result.status === 'checking') {
          statusEl.textContent = 'Checking... (' + (attempts + 1) + 's)';
          attempts++;
          continue;
        }
        if (result.available) {
          statusEl.textContent = 'Update available: ' + (result.latestVersion || '') + '. ' + (result.message || '');
          statusEl.style.color = 'var(--black)';
        } else if (result.errorCode) {
          statusEl.textContent = result.message || 'Check failed';
          statusEl.style.color = 'var(--gray-2)';
        } else {
          statusEl.textContent = result.message || 'Already on latest version.';
          statusEl.style.color = 'var(--gray-4)';
        }
        break;
      }
      if (attempts >= maxAttempts) {
        statusEl.textContent = 'Check timed out. Try again.';
        statusEl.style.color = 'var(--gray-2)';
      }
    } catch (e) {
      statusEl.textContent = 'Error: ' + e.message;
      statusEl.style.color = 'var(--gray-2)';
    }
    btn.disabled = false;
    btn.textContent = 'Check for Updates';
  }

  async function forgetWifi(ssid) {
    if (!confirm("Forget " + ssid + "?")) return;
    try {
      const response = await fetch('/api/wifi/forget', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ ssid: ssid })
      });
      if (response.ok) {
        showMessage("Forgotten " + ssid, false);
        scanWifi();
      } else {
        throw new Error(await response.text());
      }
    } catch (e) {
      showMessage("Error: " + e.message, true);
    }
  }

  async function uploadFont() {
    const input = document.getElementById('fontFileInput');
    const status = document.getElementById('fontUploadStatus');
    const btn = document.getElementById('fontUploadBtn');

    if (!input.files || input.files.length === 0) {
      status.textContent = 'No file selected.';
      return;
    }

    const file = input.files[0];
    if (!file.name.toLowerCase().endsWith('.cpf')) {
      status.textContent = 'Only .cpf files are accepted.';
      return;
    }

    btn.disabled = true;
    status.textContent = 'Uploading...';

    const formData = new FormData();
    formData.append('file', file, file.name);

    try {
      const response = await fetch('/api/user-fonts/upload', {
        method: 'POST',
        body: formData
      });

      if (response.ok) {
        const result = await response.json();
        status.textContent = 'Uploaded! ' + result.families + ' font family/families available.';
        input.value = '';
        // Reload settings to refresh the External Font selector
        loadSettings();
      } else {
        const text = await response.text();
        status.textContent = 'Error: ' + (text || 'Upload failed');
      }
    } catch (e) {
      status.textContent = 'Error: ' + e.message;
    }

    btn.disabled = false;
  }

  loadSettings();
</script>
</body>
</html>
